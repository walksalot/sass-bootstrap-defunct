name: Claude PR Auto-Review

on:
  pull_request:
    types: [opened, reopened, synchronize]

concurrency:
  group: pr-review-${{ github.event.pull_request.number }}
  cancel-in-progress: true

permissions:
  contents: write
  pull-requests: write
  issues: write
  actions: read

jobs:
  review:
    if: >-
      github.event.pull_request.user.login != 'copilot' &&
      github.event.pull_request.user.login != 'dependabot[bot]'
    runs-on: ubuntu-latest
    timeout-minutes: 45
    steps:
      - name: Checkout repository
        uses: actions/checkout@v6
        with:
          fetch-depth: 1

      - name: Detect Review Workflow Changes
        id: workflow_delta
        uses: actions/github-script@v8
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const pull_number = context.payload.pull_request.number;
            const files = await github.paginate(github.rest.pulls.listFiles, {
              owner,
              repo,
              pull_number,
              per_page: 100
            });

            const changed = files.some(f => f.filename === '.github/workflows/claude-code-review.yml');
            const workflowOnly = files.length > 0 && files.every(f => f.filename.startsWith('.github/'));
            core.setOutput('review_workflow_changed', changed ? 'true' : 'false');
            core.setOutput('workflow_only', workflowOnly ? 'true' : 'false');
            core.info(`Review workflow file changed in this PR: ${changed}`);
            core.info(`PR modifies only .github/** files: ${workflowOnly}`);

      - name: Claude Code Review (Primary)
        id: primary_review
        if: steps.workflow_delta.outputs.review_workflow_changed != 'true'
        timeout-minutes: 15
        continue-on-error: true
        uses: anthropics/claude-code-action@v1
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          github_token: ${{ github.token }}
          allowed_bots: 'claude,claude[bot],app/claude,github-actions[bot]'
          use_sticky_comment: false
          track_progress: 'false'
          claude_args: |
            --model claude-opus-4-6
            --max-turns 28
            --disallowedTools WebFetch,WebSearch
          prompt: |
            Review pull request #${{ github.event.pull_request.number }} in ${{ github.repository }}.
            At the top of your final review comment, include EXACTLY one verdict line:
            - VERDICT: APPROVED_FOR_MERGE
            - VERDICT: NOT_APPROVED_FOR_MERGE

            If not approved, include:
            1) Why it is not approved (plain English)
            2) REQUIRED_CHANGES as a numbered checklist with concrete file/behavior fixes
            3) Inline code comments for each blocking issue when a file/line is identifiable

            Focus only on high-impact findings (P0-P2): correctness, security, data integrity, user-visible regressions.
            Skip style-only and low-value nits.
            Use only repository-local context (PR diff/files and git/github tools). Do not browse external web pages.

      - name: Claude Code Review (Fallback)
        id: fallback_review
        if: steps.workflow_delta.outputs.review_workflow_changed != 'true' && steps.primary_review.outcome == 'failure'
        timeout-minutes: 4
        continue-on-error: true
        uses: anthropics/claude-code-action@v1
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          github_token: ${{ github.token }}
          allowed_bots: 'claude,claude[bot],app/claude,github-actions[bot]'
          use_sticky_comment: false
          track_progress: 'false'
          claude_args: |
            --model claude-opus-4-6
            --max-turns 8
            --disallowedTools WebFetch,WebSearch
          prompt: |
            Review pull request #${{ github.event.pull_request.number }} in ${{ github.repository }}.
            At the top of your final review comment, include EXACTLY one verdict line:
            - VERDICT: APPROVED_FOR_MERGE
            - VERDICT: NOT_APPROVED_FOR_MERGE

            Fallback mode: report only blocking issues (P0-P1). Skip optional improvements and nits.
            If not approved, include a REQUIRED_CHANGES numbered checklist with only must-fix items.
            Use only repository-local context (PR diff/files and git/github tools). Do not browse external web pages.

      - name: Resolve Review Verdict
        id: verdict
        if: always()
        uses: actions/github-script@v8
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const prNumber = context.payload.pull_request.number;
            const headSha = context.payload.pull_request.head.sha;
            const workflowChanged = '${{ steps.workflow_delta.outputs.review_workflow_changed }}' === 'true';
            const workflowOnly = '${{ steps.workflow_delta.outputs.workflow_only }}' === 'true';
            const primaryOutcome = '${{ steps.primary_review.outcome }}';
            const fallbackOutcome = '${{ steps.fallback_review.outcome }}';
            const allowedReviewAuthors = new Set(['claude', 'claude[bot]', 'app/claude']);

            const { data: commits } = await github.rest.pulls.listCommits({
              owner,
              repo,
              pull_number: prNumber,
              per_page: 100
            });
            const latestCommit = commits[commits.length - 1];
            const latestCommitDate = latestCommit
              ? new Date(latestCommit.commit.committer.date)
              : new Date(0);

            const issueComments = await github.paginate(github.rest.issues.listComments, {
              owner,
              repo,
              issue_number: prNumber,
              per_page: 100
            });

            const verdictRegex = /VERDICT:\s*(APPROVED_FOR_MERGE|NOT_APPROVED_FOR_MERGE)/i;
            const recentClaudeComments = issueComments
              .filter(comment => allowedReviewAuthors.has(comment.user?.login || ''))
              .filter(comment => new Date(comment.created_at) > latestCommitDate)
              .sort((a, b) => new Date(b.created_at) - new Date(a.created_at));
            const verdictComment =
              recentClaudeComments.find(comment => verdictRegex.test(comment.body || '')) ||
              issueComments
                .filter(comment => allowedReviewAuthors.has(comment.user?.login || ''))
                .sort((a, b) => new Date(b.created_at) - new Date(a.created_at))
                .find(comment => verdictRegex.test(comment.body || ''));

            let verdict = 'NOT_APPROVED_FOR_MERGE';
            let actionable = false;
            let reason = 'Claude review did not produce a usable verdict for this commit (review infrastructure failure).';

            if (workflowChanged) {
              verdict = 'APPROVED_FOR_MERGE';
              reason = 'This PR changes the review workflow file, so review is intentionally skipped by policy.';
            } else if (
              workflowOnly &&
              !verdictComment &&
              primaryOutcome === 'failure' &&
              fallbackOutcome === 'failure'
            ) {
              verdict = 'APPROVED_FOR_MERGE';
              actionable = false;
              reason = 'Claude review infrastructure failed, but this PR only changes .github/** files; approving via safe workflow-only fallback.';
            } else if (verdictComment) {
              const body = verdictComment.body || '';
              if (/VERDICT:\s*APPROVED_FOR_MERGE/i.test(body)) {
                verdict = 'APPROVED_FOR_MERGE';
                reason = 'Claude explicitly approved this PR for merge.';
              } else {
                verdict = 'NOT_APPROVED_FOR_MERGE';
                actionable = /REQUIRED_CHANGES/i.test(body);
                reason = actionable
                  ? 'Claude requested required code changes before merge.'
                  : 'Claude did not provide REQUIRED_CHANGES for this commit; auto-fix is skipped.';
              }
            } else if (primaryOutcome === 'success' || fallbackOutcome === 'success') {
              verdict = 'NOT_APPROVED_FOR_MERGE';
              actionable = false;
              reason = 'Claude review succeeded but did not post an explicit VERDICT line for this commit; rerun review.';
            }

            core.setOutput('verdict', verdict);
            core.setOutput('actionable', actionable ? 'true' : 'false');
            core.setOutput('reason', reason);
            core.setOutput('primary_outcome', primaryOutcome);
            core.setOutput('fallback_outcome', fallbackOutcome);

      - name: Finalize Review Status
        if: always()
        run: |
          PRIMARY="${{ steps.verdict.outputs.primary_outcome }}"
          FALLBACK="${{ steps.verdict.outputs.fallback_outcome }}"
          VERDICT="${{ steps.verdict.outputs.verdict }}"

          echo "Primary outcome: $PRIMARY"
          echo "Fallback outcome: $FALLBACK"
          echo "Review workflow changed: ${{ steps.workflow_delta.outputs.review_workflow_changed }}"
          echo "Resolved verdict: $VERDICT"
          echo "Actionable: ${{ steps.verdict.outputs.actionable }}"
          echo "Reason: ${{ steps.verdict.outputs.reason }}"

          {
            echo "### Review Bot Result"
            echo ""
            echo "- Primary run: \`$PRIMARY\`"
            echo "- Fallback run: \`$FALLBACK\`"
            echo "- Workflow self-change detected: \`${{ steps.workflow_delta.outputs.review_workflow_changed }}\`"
            echo "- Resolved verdict: \`$VERDICT\`"
            echo "- Actionable: \`${{ steps.verdict.outputs.actionable }}\`"
            echo "- Reason: ${{ steps.verdict.outputs.reason }}"
          } >> "$GITHUB_STEP_SUMMARY"

          if [ "$VERDICT" = "APPROVED_FOR_MERGE" ]; then
            echo "- Final decision: \`APPROVED_FOR_MERGE\`" >> "$GITHUB_STEP_SUMMARY"
            exit 0
          fi

          echo "- Final decision: \`NOT_APPROVED_FOR_MERGE\`" >> "$GITHUB_STEP_SUMMARY"
          exit 1

      - name: Publish Explicit Review Verdict
        if: always()
        uses: actions/github-script@v8
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const prNumber = context.payload.pull_request.number;
            const headSha = context.payload.pull_request.head.sha;
            const verdict = '${{ steps.verdict.outputs.verdict }}';
            const actionable = '${{ steps.verdict.outputs.actionable }}' === 'true';
            const reason = '${{ steps.verdict.outputs.reason }}';

            const why = [reason];
            const next = verdict === 'APPROVED_FOR_MERGE'
              ? ['No blocking review changes are required before merge.']
              : (actionable
                ? [
                    'Address all REQUIRED_CHANGES checklist items from Claude review comments.',
                    'Push the fixes to this PR branch.',
                    'A new automatic review will run and re-evaluate merge approval.'
                  ]
                : [
                    'No code auto-fix will run for this commit because the failure is non-actionable.',
                    'Re-run review or fix review workflow infrastructure, then push/retry this PR.'
                  ]);

            const marker = `<!-- review-verdict:${headSha} -->`;
            const body = [
              marker,
              '## Review Verdict',
              '',
              `VERDICT: ${verdict}`,
              `ACTIONABLE: ${actionable ? 'true' : 'false'}`,
              '',
              'Why:',
              ...why.map(item => `- ${item}`),
              '',
              'What to do next:',
              ...next.map(item => `- ${item}`)
            ].join('\n');

            const comments = await github.paginate(github.rest.issues.listComments, {
              owner,
              repo,
              issue_number: prNumber,
              per_page: 100
            });
            const existing = comments.find(comment => comment.body?.includes(marker));

            if (existing) {
              await github.rest.issues.updateComment({
                owner,
                repo,
                comment_id: existing.id,
                body
              });
              return;
            }

            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: prNumber,
              body
            });
