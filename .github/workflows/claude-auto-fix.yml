name: Claude Auto-Fix & Auto-Merge

on:
  workflow_run:
    workflows: ["Claude PR Auto-Review", "Automation Gate"]
    types: [completed]

permissions:
  contents: write
  pull-requests: write
  issues: write
  id-token: write
  actions: read
  checks: read

jobs:
  auto-fix:
    if: >-
      github.event.workflow_run.conclusion != 'cancelled' &&
      (
        (github.event.workflow_run.name == 'Claude PR Auto-Review' && github.event.workflow_run.conclusion == 'failure') ||
        (github.event.workflow_run.name == 'Automation Gate' && github.event.workflow_run.conclusion == 'success')
      )
    runs-on: ubuntu-latest
    timeout-minutes: 45
    concurrency:
      group: auto-fix-pr-${{ github.event.workflow_run.pull_requests[0].number || github.event.workflow_run.id }}
      cancel-in-progress: false
    env:
      AUTO_FIX_ENABLED: ${{ vars.AUTO_FIX_ENABLED }}
      AUTO_MERGE_ENABLED: ${{ vars.AUTO_MERGE_ENABLED }}
      WORKFLOW_SAFETY_REQUIRED: ${{ vars.WORKFLOW_SAFETY_REQUIRED }}
    steps:
      - name: Checkout workflow scripts
        uses: actions/checkout@v6
        with:
          fetch-depth: 1

      - name: Resolve PR context and review comments
        id: context
        uses: actions/github-script@v8
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const triggerWorkflow = context.payload.workflow_run.name;
            const triggerConclusion = context.payload.workflow_run.conclusion || 'unknown';
            const autoFixEnabled = process.env.AUTO_FIX_ENABLED !== 'false';
            const autoMergeEnabled = process.env.AUTO_MERGE_ENABLED !== 'false';
            const workflowSafetyRequired = process.env.WORKFLOW_SAFETY_REQUIRED !== 'false';
            const prs = context.payload.workflow_run.pull_requests || [];

            core.setOutput('trigger_workflow', triggerWorkflow);
            core.setOutput('trigger_conclusion', triggerConclusion);
            core.setOutput('auto_fix_enabled', autoFixEnabled ? 'true' : 'false');
            core.setOutput('auto_merge_enabled', autoMergeEnabled ? 'true' : 'false');
            core.setOutput('workflow_safety_required', workflowSafetyRequired ? 'true' : 'false');

            if (prs.length === 0) {
              core.info('No pull request attached to this workflow_run event.');
              core.setOutput('has_pr', 'false');
              core.setOutput('should_run', 'false');
              core.setOutput('should_evaluate_merge', 'false');
              core.setOutput('reason', 'no_pr');
              return;
            }

            const prNumber = prs[0].number;
            const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
            const labelNames = (pr.labels || []).map(label => label.name);
            const hasNoAutoFix = labelNames.includes('no-auto-fix');
            const hasNoAutoMerge = labelNames.includes('no-auto-merge');
            const isReviewFailureEvent = triggerWorkflow === 'Claude PR Auto-Review' && triggerConclusion === 'failure';

            core.setOutput('has_pr', 'true');
            core.setOutput('pr_number', String(prNumber));
            core.setOutput('pr_branch', pr.head.ref);
            core.setOutput('pr_head_sha', pr.head.sha);
            core.setOutput('pr_base_branch', pr.base.ref);
            core.setOutput('has_no_auto_fix', hasNoAutoFix ? 'true' : 'false');
            core.setOutput('has_no_auto_merge', hasNoAutoMerge ? 'true' : 'false');
            core.setOutput('should_evaluate_merge', autoMergeEnabled && !hasNoAutoMerge ? 'true' : 'false');
            core.setOutput('is_review_failure_event', isReviewFailureEvent ? 'true' : 'false');

            if (!isReviewFailureEvent) {
              core.info(`Workflow trigger is ${triggerWorkflow}/${triggerConclusion}; auto-fix run requires Claude PR Auto-Review failure.`);
              core.setOutput('should_run', 'false');
              core.setOutput('reason', 'not_review_failure_event');
              return;
            }

            const { data: comments } = await github.rest.pulls.listReviewComments({
              owner,
              repo,
              pull_number: prNumber,
              sort: 'created',
              direction: 'desc',
              per_page: 100
            });
            const issueComments = await github.paginate(github.rest.issues.listComments, {
              owner,
              repo,
              issue_number: prNumber,
              per_page: 100
            });
            const { data: commits } = await github.rest.pulls.listCommits({
              owner,
              repo,
              pull_number: prNumber,
              per_page: 100
            });

            const latestCommit = commits[commits.length - 1];
            const latestCommitDate = latestCommit
              ? new Date(latestCommit.commit.committer.date)
              : new Date(0);

            const allowedBotLogins = new Set(['claude', 'claude[bot]', 'app/claude', 'github-actions[bot]']);

            const freshBotReviewComments = comments.filter(comment => {
              if (comment.user?.type !== 'Bot' || !allowedBotLogins.has(comment.user?.login || '')) {
                return false;
              }
              return new Date(comment.created_at) > latestCommitDate;
            });
            const freshActionableNotApprovedVerdicts = issueComments.filter(comment => {
              if (comment.user?.type !== 'Bot' || !allowedBotLogins.has(comment.user?.login || '')) {
                return false;
              }
              if (!comment.body?.includes('VERDICT: NOT_APPROVED_FOR_MERGE')) {
                return false;
              }
              if (!comment.body?.includes('ACTIONABLE: true')) {
                return false;
              }
              return new Date(comment.created_at) > latestCommitDate;
            });

            const totalFreshSignals = freshBotReviewComments.length + freshActionableNotApprovedVerdicts.length;
            core.setOutput('comment_count', String(totalFreshSignals));

            if (totalFreshSignals === 0) {
              core.info('No fresh actionable NOT_APPROVED verdict signal after the latest commit.');
              core.setOutput('should_run', 'false');
              core.setOutput('reason', 'no_fresh_actionable_not_approved_signals');
              return;
            }

            const commentSetIds = [
              ...freshBotReviewComments.map(comment => `review:${comment.id}`),
              ...freshActionableNotApprovedVerdicts.map(comment => `issue:${comment.id}`)
            ].sort();
            const commentSetKey = `${pr.head.sha}:${commentSetIds.join(',')}`;
            const marker = `<!-- auto-fix-cycle:${commentSetKey} -->`;
            core.setOutput('comment_set_key', commentSetKey);

            const alreadyHandled = issueComments.some(comment => comment.body?.includes(marker));
            core.setOutput('already_handled', alreadyHandled ? 'true' : 'false');

            if (!autoFixEnabled) {
              core.info('AUTO_FIX_ENABLED is false; skipping auto-fix run.');
              core.setOutput('should_run', 'false');
              core.setOutput('reason', 'auto_fix_disabled');
              return;
            }

            if (hasNoAutoFix) {
              core.info('PR has no-auto-fix label; skipping auto-fix run.');
              core.setOutput('should_run', 'false');
              core.setOutput('reason', 'no_auto_fix_label');
              return;
            }

            if (alreadyHandled) {
              core.info('This review comment set was already handled; skipping duplicate auto-fix cycle.');
              core.setOutput('should_run', 'false');
              core.setOutput('reason', 'already_handled_comment_set');
              return;
            }

            core.info(`Will run auto-fix for ${totalFreshSignals} fresh NOT_APPROVED signal(s).`);
            core.setOutput('should_run', 'true');
            core.setOutput('reason', 'fresh_not_approved_signals_found');

      - name: Mark auto-fix cycle
        if: steps.context.outputs.should_run == 'true'
        uses: actions/github-script@v8
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const prNumber = Number.parseInt('${{ steps.context.outputs.pr_number }}', 10);
            const marker = '<!-- auto-fix-cycle:${{ steps.context.outputs.comment_set_key }} -->';

            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: prNumber,
              body: `${marker}\nü§ñ Auto-fix started for this review comment set.`
            });

      - name: Checkout PR branch
        if: steps.context.outputs.should_run == 'true'
        uses: actions/checkout@v6
        with:
          ref: ${{ steps.context.outputs.pr_branch }}
          fetch-depth: 0

      - name: Setup Node.js
        if: steps.context.outputs.should_run == 'true'
        uses: actions/setup-node@v6
        with:
          node-version: '22'

      - name: Install dependencies
        if: steps.context.outputs.should_run == 'true'
        run: npm ci

      # workflow-policy: allow-bash-star (needed for controlled build/test/git/gh commands during automated fixes)
      - name: Auto-fix review comments
        if: steps.context.outputs.should_run == 'true'
        uses: anthropics/claude-code-action@v1
        with:
          anthropic_api_key: ${{ secrets.ANTHROPIC_API_KEY }}
          claude_args: |
            --model claude-opus-4-6
            --max-turns 50
          settings: |
            {
              "permissions": {
                "allow": [
                  "Read", "Edit", "Write", "Glob", "Grep", "LS",
                  "WebSearch", "WebFetch", "Task", "Bash(*)"
                ]
              }
            }
          prompt: |
            You are auto-fixing required changes for PR #${{ steps.context.outputs.pr_number }}.

            ## Steps

            1. Read blocking review signals:
               ```
               gh api repos/${{ github.repository }}/pulls/${{ steps.context.outputs.pr_number }}/comments --jq '.[] | select(.user.type == "Bot") | {path, line, body}'
               gh api repos/${{ github.repository }}/issues/${{ steps.context.outputs.pr_number }}/comments --jq '.[] | select((.user.type == "Bot") and (.body | contains("VERDICT: NOT_APPROVED_FOR_MERGE"))) | {created_at, body}'
               ```

            2. For each REQUIRED_CHANGES item and blocking inline comment:
               - Read the file and understand the context
               - Implement the suggested fix
               - Only fix what is required for merge approval ‚Äî do NOT refactor or improve unrelated code

            3. After all fixes:
               - Build: `npm run build -w gamecam-viewer`
               - Test: `npm test -w gamecam-viewer`

            4. If build and tests pass:
               - Stage only the files you changed (not `git add -A`)
               - Commit: `git commit -m "fix: address ${{ steps.context.outputs.comment_count }} auto-review comments on PR #${{ steps.context.outputs.pr_number }}"`
               - Push: `git push origin ${{ steps.context.outputs.pr_branch }}`
               - Comment on the PR summarizing what you fixed:
                 `gh pr comment ${{ steps.context.outputs.pr_number }} --body "..."`

            5. If build or tests fail:
               - Do NOT commit or push
               - Comment on the PR explaining what went wrong so a human can take over:
                 `gh pr comment ${{ steps.context.outputs.pr_number }} --body "Auto-fix attempted but build/tests failed. Manual intervention needed."`

            ## Important
            - Read CLAUDE.md for project conventions
            - Only fix issues required to move verdict from NOT_APPROVED_FOR_MERGE to APPROVED_FOR_MERGE
            - If a comment is subjective or unclear, skip it and mention it in your summary
            - Do NOT add features, refactor, or make improvements beyond what was requested
          additional_permissions: |
            actions: read
            checks: read

      - name: Detect post-fix head SHA
        id: post_fix
        if: "!cancelled() && steps.context.outputs.should_run == 'true'"
        uses: actions/github-script@v8
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const prNumber = Number.parseInt('${{ steps.context.outputs.pr_number }}', 10);
            const expectedSha = '${{ steps.context.outputs.pr_head_sha }}';

            const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
            const shaChanged = pr.head.sha !== expectedSha;

            core.setOutput('sha_changed', shaChanged ? 'true' : 'false');
            core.setOutput('current_sha', pr.head.sha);

            if (shaChanged) {
              core.info(`PR head changed from ${expectedSha.slice(0, 7)} to ${pr.head.sha.slice(0, 7)} after auto-fix.`);
            } else {
              core.info('PR head SHA unchanged after auto-fix run.');
            }

      - name: Evaluate merge eligibility
        id: eligibility
        if: >-
          !cancelled() &&
          steps.context.outputs.has_pr == 'true' &&
          steps.context.outputs.should_evaluate_merge == 'true' &&
          (steps.context.outputs.should_run != 'true' || steps.post_fix.outputs.sha_changed == 'false')
        env:
          GITHUB_TOKEN: ${{ github.token }}
          OWNER: ${{ github.repository_owner }}
          REPO: ${{ github.event.repository.name }}
          PR_NUMBER: ${{ steps.context.outputs.pr_number }}
          HEAD_SHA: ${{ steps.context.outputs.pr_head_sha }}
          REQUIRE_WORKFLOW_SAFETY: ${{ steps.context.outputs.workflow_safety_required }}
        run: |
          RESULT_JSON=$(node .github/scripts/merge-eligibility.mjs \
            --owner "$OWNER" \
            --repo "$REPO" \
            --pr-number "$PR_NUMBER" \
            --head-sha "$HEAD_SHA" \
            --require-workflow-safety "$REQUIRE_WORKFLOW_SAFETY")

          echo "$RESULT_JSON" > /tmp/merge-eligibility.json
          cat /tmp/merge-eligibility.json

          {
            echo "eligible=$(jq -r '.eligible' /tmp/merge-eligibility.json)"
            echo "reason=$(jq -r '.reason' /tmp/merge-eligibility.json)"
            echo "details=$(jq -r '.details' /tmp/merge-eligibility.json)"
            echo "requires_workflow_safety=$(jq -r '.requires_workflow_safety' /tmp/merge-eligibility.json)"
          } >> "$GITHUB_OUTPUT"

      - name: Update branch when behind main
        if: steps.eligibility.outputs.reason == 'behind_main'
        uses: actions/github-script@v8
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const prNumber = Number.parseInt('${{ steps.context.outputs.pr_number }}', 10);
            const headSha = '${{ steps.context.outputs.pr_head_sha }}';
            const baseBranch = '${{ steps.context.outputs.pr_base_branch }}';
            const marker = `<!-- auto-merge-reason:behind_main:${headSha} -->`;
            const body = `${marker}\n‚è≥ Auto-merge paused: this PR is behind \`${baseBranch}\`. I requested a branch update and will re-check on the next run.`;

            try {
              await github.rest.pulls.updateBranch({ owner, repo, pull_number: prNumber });
            } catch (error) {
              core.warning(`Failed to update PR branch: ${error.message}`);
            }

            const comments = await github.paginate(github.rest.issues.listComments, {
              owner,
              repo,
              issue_number: prNumber,
              per_page: 100
            });
            const alreadyPosted = comments.some(comment => comment.body?.includes(marker));
            if (!alreadyPosted) {
              await github.rest.issues.createComment({ owner, repo, issue_number: prNumber, body });
            }

      - name: Post safety skip reason
        if: >-
          steps.eligibility.outputs.reason != '' &&
          steps.eligibility.outputs.reason != 'safe_to_merge' &&
          steps.eligibility.outputs.reason != 'behind_main'
        uses: actions/github-script@v8
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const prNumber = Number.parseInt('${{ steps.context.outputs.pr_number }}', 10);
            const headSha = '${{ steps.context.outputs.pr_head_sha }}';
            const reason = '${{ steps.eligibility.outputs.reason }}';
            const details = ${{ toJSON(steps.eligibility.outputs.details) }};

            const reasonMessages = {
              merge_conflict: '‚ö†Ô∏è Auto-merge blocked because this PR has merge conflicts with its base branch.',
              review_failed: '‚ö†Ô∏è Auto-merge blocked because the review check failed.',
              workflow_safety_missing: '‚ö†Ô∏è Auto-merge blocked because `Workflow Safety` is required but missing for workflow-file changes.',
              workflow_safety_failed: '‚ö†Ô∏è Auto-merge blocked because `Workflow Safety` failed.',
              sha_mismatch: '‚ö†Ô∏è Auto-merge skipped because the PR head changed while evaluating.',
              pending_checks: '‚è≥ Auto-merge waiting: required checks are still running or failed.'
            };

            const message = reasonMessages[reason];
            if (!message) {
              core.info(`No safety comment needed for reason: ${reason}`);
              return;
            }

            const marker = `<!-- auto-merge-reason:${reason}:${headSha} -->`;
            const body = `${marker}\n${message}\n\nDetails: ${details}`;

            const comments = await github.paginate(github.rest.issues.listComments, {
              owner,
              repo,
              issue_number: prNumber,
              per_page: 100
            });
            const alreadyPosted = comments.some(comment => comment.body?.includes(marker));
            if (!alreadyPosted) {
              await github.rest.issues.createComment({ owner, repo, issue_number: prNumber, body });
            }

      - name: Re-check SHA before merge
        id: recheck
        if: steps.eligibility.outputs.reason == 'safe_to_merge'
        uses: actions/github-script@v8
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const prNumber = Number.parseInt('${{ steps.context.outputs.pr_number }}', 10);
            const expectedSha = '${{ steps.context.outputs.pr_head_sha }}';

            const { data: pr } = await github.rest.pulls.get({ owner, repo, pull_number: prNumber });
            if (pr.head.sha !== expectedSha) {
              core.info(`PR head changed to ${pr.head.sha.slice(0, 7)}; skipping merge for this run.`);
              core.setOutput('should_merge', 'false');
              return;
            }

            core.setOutput('should_merge', 'true');

      - name: Auto-merge PR
        if: steps.recheck.outputs.should_merge == 'true'
        uses: actions/github-script@v8
        with:
          script: |
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const prNumber = Number.parseInt('${{ steps.context.outputs.pr_number }}', 10);

            try {
              await github.rest.pulls.merge({
                owner,
                repo,
                pull_number: prNumber,
                merge_method: 'squash'
              });

              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: prNumber,
                body: '‚úÖ **Auto-merged** ‚Äî required checks passed and safety gates were satisfied.'
              });
            } catch (error) {
              core.warning(`Auto-merge failed: ${error.message}`);
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: prNumber,
                body: `‚ö†Ô∏è Auto-merge attempted but failed: \`${error.message}\``
              });
            }
