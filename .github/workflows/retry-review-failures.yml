name: Retry Failed Review Runs

on:
  workflow_run:
    workflows: ["Claude PR Auto-Review"]
    types: [completed]

jobs:
  retry-failed-review:
    if: github.event.workflow_run.conclusion == 'failure'
    runs-on: ubuntu-latest
    timeout-minutes: 10
    permissions:
      actions: write
      checks: read
      contents: write
      pull-requests: write
      issues: write
    env:
      REVIEW_RETRY_ENABLED: ${{ vars.REVIEW_RETRY_ENABLED }}
      REVIEW_RETRY_MAX: ${{ vars.REVIEW_RETRY_MAX }}
    steps:
      - name: Retry failed review run with bounded attempts per PR SHA
        uses: actions/github-script@v8
        with:
          github-token: ${{ github.token }}
          script: |
            const enabled = process.env.REVIEW_RETRY_ENABLED !== 'false';
            if (!enabled) {
              core.info('REVIEW_RETRY_ENABLED=false; skipping review retry worker.');
              return;
            }

            const parsedRetryMax = Number.parseInt(process.env.REVIEW_RETRY_MAX || '3', 10);
            const retryMax = Number.isFinite(parsedRetryMax) && parsedRetryMax > 0 ? parsedRetryMax : 3;

            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const reviewRun = context.payload.workflow_run;
            const prs = reviewRun.pull_requests || [];

            if (prs.length === 0) {
              core.info('No PR attached to failed review run.');
              return;
            }

            const prNumber = prs[0].number;
            const headSha = reviewRun.head_sha;
            const legacyMarker = `<!-- review-retry:${headSha} -->`;
            const markerPrefix = `<!-- review-retry:${headSha}:attempt:`;
            const exhaustedMarker = `<!-- review-retry-exhausted:${headSha} -->`;

            async function postDedupComment(commentMarker, body) {
              const existingComments = await github.paginate(github.rest.issues.listComments, {
                owner,
                repo,
                issue_number: prNumber,
                per_page: 100
              });
              if (existingComments.some(comment => comment.body?.includes(commentMarker))) {
                return;
              }
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: prNumber,
                body
              });
            }

            const comments = await github.paginate(github.rest.issues.listComments, {
              owner,
              repo,
              issue_number: prNumber,
              per_page: 100
            });

            const attemptsFromNewMarkers = comments.filter(comment => comment.body?.includes(markerPrefix)).length;
            const attemptsFromLegacyMarkers = comments.some(comment => comment.body?.includes(legacyMarker)) ? 1 : 0;
            const attemptsSoFar = attemptsFromNewMarkers + attemptsFromLegacyMarkers;
            if (attemptsSoFar >= retryMax) {
              await postDedupComment(
                exhaustedMarker,
                `${exhaustedMarker}\n‚ö†Ô∏è Review retry worker reached max attempts (${retryMax}) for \`${headSha.slice(0, 7)}\`. No further automatic reruns will be triggered for this commit SHA.`
              );
              core.info(`Retry limit reached for PR #${prNumber} on ${headSha.slice(0, 7)} (${attemptsSoFar}/${retryMax}).`);
              return;
            }
            const nextAttempt = attemptsSoFar + 1;
            const attemptMarker = `${markerPrefix}${nextAttempt} -->`;

            const { data: pr } = await github.rest.pulls.get({
              owner,
              repo,
              pull_number: prNumber
            });

            if (pr.state !== 'open') {
              core.info(`PR #${prNumber} is not open; skipping retry.`);
              return;
            }

            if (pr.head.sha !== headSha) {
              core.info(
                `PR #${prNumber} moved from ${headSha.slice(0, 7)} to ${pr.head.sha.slice(0, 7)}; skipping stale retry.`
              );
              return;
            }

            let checkRunsResponse;
            try {
              checkRunsResponse = await github.rest.checks.listForRef({
                owner,
                repo,
                ref: headSha,
                per_page: 100
              });
            } catch (error) {
              const status = error.status || 0;
              const permissionMarker = `<!-- review-retry-permission:${headSha} -->`;
              const isPermissionError = status === 403 || status === 401;
              if (isPermissionError) {
                await postDedupComment(
                  permissionMarker,
                  `${permissionMarker}\n‚ö†Ô∏è Review retry worker could not read check-runs due to permissions (${status}). Exiting safely; no retry loop was triggered.`
                );
                core.warning(`Permission denied reading check-runs: ${error.message}`);
                return;
              }

              throw error;
            }
            const failingReview = (checkRunsResponse.data.check_runs || []).find(
              checkRun => checkRun.name === 'review' && checkRun.conclusion === 'failure'
            );

            if (!failingReview) {
              core.info(`No failing review check found for ${headSha.slice(0, 7)}.`);
              return;
            }

            const reviewVerdictMarker = `<!-- review-verdict:${headSha} -->`;
            const verdictComment = comments
              .filter(comment => comment.body?.includes(reviewVerdictMarker))
              .sort((a, b) => new Date(b.created_at) - new Date(a.created_at))[0];

            if (verdictComment) {
              const body = verdictComment.body || '';
              const approved = /VERDICT:\s*APPROVED_FOR_MERGE/i.test(body);
              const actionable = /ACTIONABLE:\s*true/i.test(body);
              const nonActionable = /ACTIONABLE:\s*false/i.test(body);

              if (approved) {
                core.info(`Latest verdict is APPROVED_FOR_MERGE for ${headSha.slice(0, 7)}; no retry needed.`);
                return;
              }

              if (actionable) {
                const actionableMarker = `<!-- review-retry-skipped-actionable:${headSha} -->`;
                await postDedupComment(
                  actionableMarker,
                  `${actionableMarker}\n‚ÑπÔ∏è Review retry worker skipped rerun for \`${headSha.slice(0, 7)}\` because Claude returned \`ACTIONABLE: true\` (required code changes).`
                );
                core.info(`Latest verdict is actionable for ${headSha.slice(0, 7)}; skipping retry.`);
                return;
              }

              if (nonActionable) {
                core.info(`Latest verdict is non-actionable for ${headSha.slice(0, 7)}; retry is allowed.`);
              }
            }

            if (pr.mergeable_state === 'behind') {
              try {
                await github.rest.pulls.updateBranch({
                  owner,
                  repo,
                  pull_number: prNumber
                });

                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: prNumber,
                  body: `${attemptMarker}\nüîÅ Review retry worker updated this branch from \`${pr.base.ref}\` because it was behind. New checks should start automatically. (attempt ${nextAttempt}/${retryMax})`
                });
              } catch (error) {
                const status = error.status || 0;
                if (status === 403 || status === 401) {
                  const permissionMarker = `<!-- review-retry-permission-update:${headSha} -->`;
                  await postDedupComment(
                    permissionMarker,
                    `${permissionMarker}\n‚ö†Ô∏è Review retry worker could not update this branch due to permissions (${status}). Exiting safely.`
                  );
                  core.warning(`Permission denied updating PR #${prNumber} branch before retry: ${error.message}`);
                  return;
                }
                core.warning(`Failed to update PR #${prNumber} branch before retry: ${error.message}`);
              }
              return;
            }

            try {
              await github.request('POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs', {
                owner,
                repo,
                run_id: reviewRun.id
              });
            } catch (error) {
              core.warning(`rerun-failed-jobs failed: ${error.message}. Falling back to full rerun.`);
              try {
                await github.request('POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun', {
                  owner,
                  repo,
                  run_id: reviewRun.id
                });
              } catch (fallbackError) {
                const status = fallbackError.status || 0;
                if (status === 403 || status === 401) {
                  const permissionMarker = `<!-- review-retry-permission-rerun:${headSha} -->`;
                  await postDedupComment(
                    permissionMarker,
                    `${permissionMarker}\n‚ö†Ô∏è Review retry worker could not re-run workflow due to permissions (${status}). Exiting safely.`
                  );
                  core.warning(`Permission denied re-running failed review workflow: ${fallbackError.message}`);
                  return;
                }
                throw fallbackError;
              }
            }

            await postDedupComment(
              attemptMarker,
              `${attemptMarker}\nüîÅ Review retry worker re-ran the failed review workflow (attempt ${nextAttempt}/${retryMax}) for this commit SHA.`
            );

            core.info(`Triggered retry attempt ${nextAttempt}/${retryMax} for PR #${prNumber} on ${headSha.slice(0, 7)}.`);
